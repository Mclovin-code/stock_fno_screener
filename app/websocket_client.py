import loggingfrom kiteconnect import KiteTicker# Set up logginglogging.basicConfig(level=logging.DEBUG)def on_ticks(ws, ticks, update_row):    # Callback to receive ticks.    logging.debug("Ticks: {}".format(ticks))    # Assuming `ticks` contains a dictionary with necessary data    for tick in ticks:        stock = tick['instrument_token']        data = {            'spread_price': tick['last_price'],  # Example data mapping            'margin_requirement': tick['margin'],            'atm_iv': tick['iv'],            'ivp': tick['ivp'],            'risk_reward': tick['risk_reward'],            'max_profit': tick['max_profit'],            'max_loss': tick['max_loss'],            'breakeven': tick['breakeven'],            'return_pct': tick['return_pct']        }        update_row(stock, data)def on_connect(ws, response):    # Callback on successful connect.    logging.debug("Connected: {}".format(response))    # Subscribe to a list of instrument_tokens (RELIANCE and ACC here).    ws.subscribe([738561, 5633])    # Set RELIANCE to tick in `full` mode.    ws.set_mode(ws.MODE_FULL, [738561])def on_close(ws, code, reason):    # On connection close stop the event loop.    # Reconnection will not happen after executing `ws.stop()`    logging.debug("Closed: {} - {}".format(code, reason))    ws.stop()def run_websocket(update_row, api_key, access_token):    kws = KiteTicker(api_key, access_token)    # Assign the callbacks.    kws.on_ticks = lambda ws, ticks: on_ticks(ws, ticks, update_row)    kws.on_connect = on_connect    kws.on_close = on_close    # Infinite loop on the main thread. Nothing after this will run.    # You have to use the pre-defined callbacks to manage subscriptions.    kws.connect()